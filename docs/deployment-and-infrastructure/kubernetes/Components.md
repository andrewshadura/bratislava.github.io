---
sidebar_position: 4
---

# Kubernetes components

All components are autogenerated by pipeline in monorepo. This is only for understanding how it works and how to create manually new namespace and new app pod with all components.
You can create your component in Lens from terminal and kubectl command or by plus -> create new resource and setup your config and save. Here is example of YAML head

```yaml
apiVersion: v1
kind: service
metadata:
  name: next-new-service-test
  namespace: bratislava-monorepo
---
```

## Namespaces

Namespaces is something like group of application, in which are similar apps, or using same components etc.
you can create new namespace by terminal command: `kubectl create namespace`

## Pods

pod is the smallest deployable unit. Usually has one container, can have more, where image with config is running. All pods are created automatically by Deployment or StatefulSets (mentioned lower)

## Services

Abstract way how to run application on pod or pods. You can create a service by creating new resource. Example:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: { { service name } }
  namespace: { { your namespace } }
  labels:
    app: { { app name } }
    service: app
    source: { { app name } }
status:
  loadBalancer: {}
spec:
  ports:
    - protocol: TCP
      port: { { port where service will run } }
      targetPort: { { port where image in container / pod is running } }
  selector:
    app: platba-dani-be
    service: app
    source: platba-dani-be
```

## Endpoints

Is created automatically by service or ingress

## Ingresses

Is for forwarding endpoint to public, you can setup also DNS and letsencrypt. Example:

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: { { ingress name } }
  namespace: { { namespace name } }
  labels:
    app: { { app name } }
    service: app
    source: { { app name } }
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt
    cert-manager.io/issue-temporary-certificate: 'true'
    kubernetes.io/ingress.class: haproxy
status:
  loadBalancer:
    ingress:
      - {}
spec:
  tls:
    - hosts:
        - { { host name - dns. ... .dev.bratislava.sk } }
      secretName:
        {
          {
            name of secret,
            which will be automaticly generated,
            idealy appName-tls,
          },
        }
  rules:
    - host: { { host name - dns. ... .dev.bratislava.sk } }
      http:
        paths:
          - path: /
            pathType: ImplementationSpecific
            backend:
              service:
                name: { { service name } }
                port:
                  number: { { port were service is running } }
```

## ConfigMaps

Config map is used as .env file. In env variables, don't use values in quotes. Example:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{config map name}}
  namespace: {{namespace name}}
  labels:
    app: {{app name}}
    source: {{app name}}
data:
  NODE_ENV: production
  ...
  ...

```

## Secrets

You can genrate secret file:

- from terminal, for example:
  ```
  kubectl create secret generic test \
    --from-literal=VARIABLE_NAME=value \
    --namespace=platba-dani \
    --dry-run=client
  ```
  _NOTE:_ use dry-run=client only for test and not create, and use namespace, you can also have more --from-literal.
- from monorepo using command `nx add-secret {{app name}} --help`. In help you will see how to set variable names and values. This will create new file in kustomize folder with your suffix.

From this two possibilities, you can copy your key and insert to create new resource

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: platba-dani-be-db-secret
  namespace: bratislava-monorepo
data:
  POSTGRES_DB: cGxhdGJhLWRhbmk=
  POSTGRES_PASSWORD: WUFQTktwbndqTDdXdUVyOA==
  POSTGRES_USER: cGxhdGJhLWRhbmk=
type: { { some type } }
```

_NOTE:_ type can be opaque, generic or else from terminal exmaple or kubernetes.io/tls if it is from monrepo

## Deployments

if you want to deploy your app, setup here on which image, configMaps, Secrets, Services will it run.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: { { app deployment name } }
  namespace: { { namespace name } }
  labels:
    app: { { app name } }
    service: app
    source: { { app name } }
spec:
  replicas: 1
  selector:
    matchLabels:
      app: { { app name } }
      service: app
      source: { { app name } }
    # template:  #you can use it or not
    #   metadata:
    #     creationTimestamp: null
    #     labels:
    #       app: {{app name}}
    #       service: app
    #       source: {{app name}}
    #     annotations:
    #       repositoryUrl: >-
    #         {{repository}}
    spec:
      containers:
        - name: app
          image: >-
            {{image link in our monorepo it is on ghcr.io/...}}
          envFrom: #setup secrets and config maps this is only example
            - secretRef:
                name: { { app secret } }
            - secretRef:
                name: { { app db secret } }
            - configMapRef:
                name: { { app config map } }
          env:
            - name: DB_POSTGRES_CS #will setup new environment variable by secret from app db secret
              value: >-
                postgresql://$(POSTGRES_USER):$(POSTGRES_PASSWORD)@{{database}}:5432/$(POSTGRES_DB)?schema=public
          resources:
            limits:
              cpu: 500m
              memory: 1Gi
            requests:
              cpu: 50m
              memory: 64Mi
          terminationMessagePath: /dev/termination-log
          terminationMessagePolicy: File
          imagePullPolicy: IfNotPresent
      restartPolicy: Always
      terminationGracePeriodSeconds: 30
      dnsPolicy: ClusterFirst
      securityContext: {}
      imagePullSecrets:
        - name: ghcr-secret
      schedulerName: default-scheduler
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 25%
      maxSurge: 25%
  revisionHistoryLimit: 10
  progressDeadlineSeconds: 600
```

## StatefulSets

It is usually used for database deployment. This can be used, when you want to deploy your app with persistent storage, setup here on which image, configMaps, Secrets, Services will it run.

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: { { app stateFull name } }
  namespace: bratislava-monorepo
  labels:
    app: { { app name } }
    service: database
    source: { { app name } }
spec:
  replicas: 1
  selector:
    matchLabels:
      app: { { app name } }
      service: database
      source: { { app name } }
    # template: #you can use it or not
    #   metadata:
    #     creationTimestamp: null
    #     labels:
    #       app: {{app name}}
    #       service: database
    #       source: {{app name}}
    #     annotations:
    #       repositoryUrl: >-
    #         {{repository url}}
    spec:
      containers:
        - name: database
          image: postgres:14-alpine
          envFrom:
            - secretRef:
                name: { { db secret } }
          resources:
            limits:
              cpu: 500m
              memory: 1Gi
            requests:
              cpu: 100m
              memory: 128Mi
          volumeMounts:
            - name: postgresql
              mountPath: /var/lib/postgresql/data
              subPath: postgresql
          terminationMessagePath: /dev/termination-log
          terminationMessagePolicy: File
          imagePullPolicy: IfNotPresent
      restartPolicy: Always
      terminationGracePeriodSeconds: 30
      dnsPolicy: ClusterFirst
      securityContext: {}
      imagePullSecrets:
        - name: ghcr-secret
      schedulerName: default-scheduler
  volumeClaimTemplates:
    - kind: PersistentVolumeClaim
      apiVersion: v1
      metadata:
        name: postgresql
        creationTimestamp: null
        labels:
          app: { { app name } }
          service: database
          source: { { app name } }
      spec:
        accessModes:
          - ReadWriteOnce
        resources:
          requests:
            storage: 10Gi
        volumeMode: Filesystem
      status:
        phase: Pending
  serviceName: { { app service name } }
  podManagementPolicy: OrderedReady
  updateStrategy:
    type: RollingUpdate
    rollingUpdate:
      partition: 0
  revisionHistoryLimit: 10
```

## Others

- jobs and cronjobs
- other configurations: \
  here you can setup quotas, limits and autoscalings
- other network settings: \
  here, you can setup additional network policies and port forwarding
- storage: \
  here, you can see all volumes for pods
